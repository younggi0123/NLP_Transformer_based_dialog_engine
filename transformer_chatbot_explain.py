# -*- coding: utf-8 -*-
"""Transformer Korean Chatbot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j2A-v5xXJgZn_5IHMxgxNczezX0u__PG

위키독스 '딥 러닝을 이용한 자연어 처리 입문'의 트랜스포머 튜토리얼 기반임


챗봇의 성능이 아쉽다면 모델의 크기를 조정

링크 :  
https://wikidocs.net/31379  
https://wikidocs.net/89786
"""

import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import layers
from tensorflow.keras.layers import Dense
import os
# to solved error I got these packages
import pydot
import graphviz

# 텐서플로우 버전확인
tf.__version__

# Get the current working directory (cwd)
currentPath = os.getcwd()

# print path
print(currentPath)



# 최종 버전
# ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★트랜스포머 알고리즘부★★★★★★★★★★★★★★★★★★★★★★★★★★★★★




############################### 포지셔널 인코딩 class

# 포지셔널 인코딩을 통해 순서정보를 보존한다.
# 예로, 임베딩된 벡터값에 도지셔널 인코딩의 값을 더하면
# 같은 단어라 하더라도 문장내 위치에 따라 트랜스포머의 입력으로 들어가는 임베딩 벡터의 값이 달라진다.
# 이를 코드로 구현하면,

class PositionalEncoding(layers.Layer):
  def __init__(self, position, d_model):
    super(PositionalEncoding, self).__init__()
    self.pos_encoding = self.positional_encoding(position, d_model)

  def get_angles(self, position, i, d_model):
    angles = 1 / tf.pow(10000, (2 * (i // 2)) / tf.cast(d_model, tf.float32))
    return position * angles

  def positional_encoding(self, position, d_model):
    angle_rads = self.get_angles(
        position=tf.range(position, dtype=tf.float32)[:, tf.newaxis],
        i=tf.range(d_model, dtype=tf.float32)[tf.newaxis, :],
        d_model=d_model)

    # 사인과 코사인을 사용하는 이유
    # https://pongdangstory.tistory.com/482
    # 배열의 짝수 인덱스(2i)에는 사인 함수 적용
    sines = tf.math.sin(angle_rads[:, 0::2])

    # 배열의 홀수 인덱스(2i+1)에는 코사인 함수 적용
    cosines = tf.math.cos(angle_rads[:, 1::2])

    angle_rads = np.zeros(angle_rads.shape)
    angle_rads[:, 0::2] = sines
    angle_rads[:, 1::2] = cosines
    pos_encoding = tf.constant(angle_rads)
    pos_encoding = pos_encoding[tf.newaxis, ...]

    print(pos_encoding.shape)
    return tf.cast(pos_encoding, tf.float32)

  def call(self, inputs):
    return inputs + self.pos_encoding[:, :tf.shape(inputs)[1], :]

# 50 × 128의 크기를 가지는 포지셔널 인코딩 행렬을 시각화하여 어떤 형태를 가지는지 확인
sample_pos_encoding = PositionalEncoding(50, 128)

plt.pcolormesh(sample_pos_encoding.pos_encoding.numpy()[0], cmap='RdBu')
plt.xlabel('Depth')
plt.xlim((0, 128))
plt.ylabel('Position')
plt.colorbar()
plt.show()









############################### 어텐션

############################### 인코더

# 인코더의 첫번째 서브층 : Query = Key = Value

# 축약설명
def scaled_dot_product_attention(query, key, value, mask):
  # query 크기 : (batch_size, num_heads, query의 문장 길이, d_model/num_heads)
  # key 크기 : (batch_size, num_heads, key의 문장 길이, d_model/num_heads)
  # value 크기 : (batch_size, num_heads, value의 문장 길이, d_model/num_heads)
  # padding_mask : (batch_size, 1, 1, key의 문장 길이)

  # Q와 K의 곱. 어텐션 스코어 행렬.
  matmul_qk = tf.matmul(query, key, transpose_b=True)

  # 스케일링
  # dk의 루트값으로 나눠준다.
  depth = tf.cast(tf.shape(key)[-1], tf.float32)
  logits = matmul_qk / tf.math.sqrt(depth)

  # 패딩마스크(Padding Mask)
  # 인코더의 입력으로 들어가는 문장에는 패딩이 있을 수 있으므로, 어텐션 시 패딩 토큰을 제외하도록 패딩 마스크를 사용합니다. 이는 MultiHeadAttention 함수의 mask의 인자값으로 padding_mask가 사용되는 이유
  # 마스킹. 어텐션 스코어 행렬의 마스킹 할 위치에 매우 작은 음수값을 넣는다.
  # 매우 작은 값이므로 소프트맥스 함수를 지나면 행렬의 해당 위치의 값은 0이 된다.
  # 주관적 부가설명 : 소프트맥스를 거쳐 각 행의 어텐션 가중치의 총 합이 1이 
  
  if mask is not None:
    logits += (mask * -1e9)

  # 소프트맥스 함수는 마지막 차원인 key의 문장 길이 방향으로 수행된다.
  # attention weight : (batch_size, num_heads, query의 문장 길이, key의 문장 길이)
  attention_weights = tf.nn.softmax(logits, axis=-1)

  # output : (batch_size, num_heads, query의 문장 길이, d_model/num_heads)
  output = tf.matmul(attention_weights, value)

  return output, attention_weights




############################### 어텐션
############################### 멀티헤드 어텐션


class MultiHeadAttention(layers.Layer):

  def __init__(self, d_model, num_heads, name="multi_head_attention"):
    super(MultiHeadAttention, self).__init__(name=name)
    self.num_heads = num_heads
    self.d_model = d_model

    assert d_model % self.num_heads == 0

    # d_model을 num_heads로 나눈 값.
    # 논문 기준 : 64
    self.depth = d_model // self.num_heads

    # WQ, WK, WV에 해당하는 밀집층 정의
    self.query_dense = tf.keras.layers.Dense(units=d_model)
    self.key_dense = tf.keras.layers.Dense(units=d_model)
    self.value_dense = tf.keras.layers.Dense(units=d_model)

    # WO에 해당하는 밀집층 정의
    self.dense = tf.keras.layers.Dense(units=d_model)

  # num_heads 개수만큼 q, k, v를 split하는 함수
  def split_heads(self, inputs, batch_size):
    inputs = tf.reshape(
        inputs, shape=(batch_size, -1, self.num_heads, self.depth))
    return tf.transpose(inputs, perm=[0, 2, 1, 3])

  def call(self, inputs):
    query, key, value, mask = inputs['query'], inputs['key'], inputs[
        'value'], inputs['mask']
    batch_size = tf.shape(query)[0]

    # 1. WQ, WK, WV에 해당하는 밀집층 지나기
    # q : (batch_size, query의 문장 길이, d_model)
    # k : (batch_size, key의 문장 길이, d_model)
    # v : (batch_size, value의 문장 길이, d_model)
    # 참고) 인코더(k, v)-디코더(q) 어텐션에서는 query 길이와 key, value의 길이는 다를 수 있다.
    query = self.query_dense(query)
    key = self.key_dense(key)
    value = self.value_dense(value)

    # 2. 헤드 나누기
    # q : (batch_size, num_heads, query의 문장 길이, d_model/num_heads)
    # k : (batch_size, num_heads, key의 문장 길이, d_model/num_heads)
    # v : (batch_size, num_heads, value의 문장 길이, d_model/num_heads)
    query = self.split_heads(query, batch_size)
    key = self.split_heads(key, batch_size)
    value = self.split_heads(value, batch_size)

    # 3. 스케일드 닷 프로덕트 어텐션. 앞서 구현한 함수 사용.
    # (batch_size, num_heads, query의 문장 길이, d_model/num_heads)
    scaled_attention, _ = scaled_dot_product_attention(query, key, value, mask)
    # (batch_size, query의 문장 길이, num_heads, d_model/num_heads)
    scaled_attention = tf.transpose(scaled_attention, perm=[0, 2, 1, 3])

    # 4. 헤드 연결(concatenate)하기
    # (batch_size, query의 문장 길이, d_model)
    concat_attention = tf.reshape(scaled_attention,
                                  (batch_size, -1, self.d_model))

    # 5. WO에 해당하는 밀집층 지나기
    # (batch_size, query의 문장 길이, d_model)
    outputs = self.dense(concat_attention)

    return outputs

# 인코더의 입력으로 들어가는 문장에는 패딩이 있을 수 있으므로, 어텐션 시 패딩 토큰을 제외하도록 패딩 마스크를 사용합니다.
def create_padding_mask(x):
  mask = tf.cast(tf.math.equal(x, 0), tf.float32)
  # (batch_size, 1, 1, key의 문장 길이)
  return mask[:, tf.newaxis, tf.newaxis, :]


############################### 인코더
############################### 인코더 구현부

def encoder_layer(dff, d_model, num_heads, dropout, name="encoder_layer"):
  inputs = tf.keras.Input(shape=(None, d_model), name="inputs")

  # 인코더는 패딩 마스크 사용
  padding_mask = tf.keras.Input(shape=(1, 1, None), name="padding_mask")

  # 멀티-헤드 어텐션 (첫번째 서브층 / 셀프 어텐션)
  attention = MultiHeadAttention(
      d_model, num_heads, name="attention")({
          'query': inputs, 'key': inputs, 'value': inputs, # Q = K = V
          'mask': padding_mask # 패딩 마스크 사용
      })

  # 드롭아웃 + 잔차 연결과 층 정규화
  attention = tf.keras.layers.Dropout(rate=dropout)(attention)
  attention = layers.LayerNormalization(
      epsilon=1e-6)(inputs + attention)

  # 포지션 와이즈 피드 포워드 신경망 (두번째 서브층)
  outputs = tf.keras.layers.Dense(units=dff, activation='relu')(attention)
  outputs = tf.keras.layers.Dense(units=d_model)(outputs)

  # 드롭아웃 + 잔차 연결과 층 정규화
  outputs = tf.keras.layers.Dropout(rate=dropout)(outputs)
  outputs = layers.LayerNormalization(
      epsilon=1e-6)(attention + outputs)

  return tf.keras.Model(
      inputs=[inputs, padding_mask], outputs=outputs, name=name)




############################### 인코더
############################### 인코더 쌓기
# 인코더 층을 num_layers개만큼 쌓고, 마지막 인코더 층에서 얻는 (seq_len, d_model) 크기의 행렬을 디코더로 보내주므로서 트랜스포머 인코더의 인코딩 연산이 끝나게 됩니다.
def encoder(vocab_size, num_layers, dff,
            d_model, num_heads, dropout,
            name="encoder"):
  inputs = tf.keras.Input(shape=(None,), name="inputs")

  # 인코더는 패딩 마스크 사용
  padding_mask = tf.keras.Input(shape=(1, 1, None), name="padding_mask")

  # 포지셔널 인코딩 + 드롭아웃
  embeddings = tf.keras.layers.Embedding(vocab_size, d_model)(inputs)
  embeddings *= tf.math.sqrt(tf.cast(d_model, tf.float32))
  embeddings = PositionalEncoding(vocab_size, d_model)(embeddings)
  outputs = tf.keras.layers.Dropout(rate=dropout)(embeddings)

  # 인코더를 num_layers개 쌓기
  for i in range(num_layers):
    outputs = encoder_layer(dff=dff, d_model=d_model, num_heads=num_heads,
        dropout=dropout, name="encoder_layer_{}".format(i),
    )([outputs, padding_mask])

  return tf.keras.Model(
      inputs=[inputs, padding_mask], outputs=outputs, name=name)



############################### 디코더 설명
# 디코더의 첫번째 서브층인 마스크드 셀프 어텐션 : 룩-어헤드 마스크를 전달 <-- 지금 설명하고 있음.
#  └ 룩-어헤드 마스크를 한다고해서 패딩 마스크가 불필요한 것이 아니므로 룩-어헤드 마스크는 패딩 마스크를 포함하도록 구현
#  └ 이를 구현하는 방법은 패딩 마스크 때와 마찬가지로 마스킹을 하고자 하는 위치에는 1을, 마스킹을 하지 않는 위치에는 0을 리턴하도록 합니다.
# 디코더의 두번째 서브층인 인코더-디코더 어텐션 : 패딩 마스크를 전달

# 디코더의 첫번째 서브층 : Query = Key = Value
# 디코더의 두번째 서브층 : Query : 디코더 행렬 / Key = Value : 인코더 행렬

############################### 디코더
############################### 디코더 첫번째 서브층

# ★마지막 인코더 층에서 얻는 (seq_len, d_model) 크기의 행렬을 디코더로 보내주므로서 트랜스포머 인코더의 인코딩 연산이 끝나게 됨☆
# 디코더의 첫번째 서브층(sublayer)에서 미래 토큰을 Mask하는 함수
def create_look_ahead_mask(x):
  seq_len = tf.shape(x)[1]
  look_ahead_mask = 1 - tf.linalg.band_part(tf.ones((seq_len, seq_len)), -1, 0)
  padding_mask = create_padding_mask(x) # 패딩 마스크도 포함
  return tf.maximum(look_ahead_mask, padding_mask)


############################### 디코더
############################### 디코더 구현부

def decoder_layer(dff, d_model, num_heads, dropout, name="decoder_layer"):
  inputs = tf.keras.Input(shape=(None, d_model), name="inputs")
  enc_outputs = tf.keras.Input(shape=(None, d_model), name="encoder_outputs")

  # 디코더는 룩어헤드 마스크(첫번째 서브층)와 패딩 마스크(두번째 서브층) 둘 다 사용.
  look_ahead_mask = tf.keras.Input(
      shape=(1, None, None), name="look_ahead_mask")
  padding_mask = tf.keras.Input(shape=(1, 1, None), name='padding_mask')

  # 멀티-헤드 어텐션 (첫번째 서브층 / 마스크드 셀프 어텐션)
  attention1 = MultiHeadAttention(
      d_model, num_heads, name="attention_1")(inputs={
          'query': inputs, 'key': inputs, 'value': inputs, # Q = K = V
          'mask': look_ahead_mask # 룩어헤드 마스크
      })

  # 잔차 연결과 층 정규화
  attention1 = layers.LayerNormalization(
      epsilon=1e-6)(attention1 + inputs)

  # 멀티-헤드 어텐션 (두번째 서브층 / 디코더-인코더 어텐션)
  attention2 = MultiHeadAttention(
      d_model, num_heads, name="attention_2")(inputs={
          'query': attention1, 'key': enc_outputs, 'value': enc_outputs, # Q != K = V
          'mask': padding_mask # 패딩 마스크
      })

  # 드롭아웃 + 잔차 연결과 층 정규화
  attention2 = tf.keras.layers.Dropout(rate=dropout)(attention2)
  attention2 = layers.LayerNormalization(
      epsilon=1e-6)(attention2 + attention1)

  # 포지션 와이즈 피드 포워드 신경망 (세번째 서브층)
  outputs = tf.keras.layers.Dense(units=dff, activation='relu')(attention2)
  outputs = tf.keras.layers.Dense(units=d_model)(outputs)

  # 드롭아웃 + 잔차 연결과 층 정규화
  outputs = tf.keras.layers.Dropout(rate=dropout)(outputs)
  outputs = layers.LayerNormalization(
      epsilon=1e-6)(outputs + attention2)

  return tf.keras.Model(
      inputs=[inputs, enc_outputs, look_ahead_mask, padding_mask],
      outputs=outputs,
      name=name)



############################### 디코더
############################### 디코더 쌓기
# 포지셔널 인코딩 후 디코더 층을 num_layers의 개수만큼 쌓는 코드

def decoder(vocab_size, num_layers, dff,
            d_model, num_heads, dropout,
            name='decoder'):
  inputs = tf.keras.Input(shape=(None,), name='inputs')
  enc_outputs = tf.keras.Input(shape=(None, d_model), name='encoder_outputs')

  # 디코더는 룩어헤드 마스크(첫번째 서브층)와 패딩 마스크(두번째 서브층) 둘 다 사용.
  look_ahead_mask = tf.keras.Input(
      shape=(1, None, None), name='look_ahead_mask')
  padding_mask = tf.keras.Input(shape=(1, 1, None), name='padding_mask')

  # 포지셔널 인코딩 + 드롭아웃
  embeddings = tf.keras.layers.Embedding(vocab_size, d_model)(inputs)
  embeddings *= tf.math.sqrt(tf.cast(d_model, tf.float32))
  embeddings = PositionalEncoding(vocab_size, d_model)(embeddings)
  outputs = tf.keras.layers.Dropout(rate=dropout)(embeddings)

  # 디코더를 num_layers개 쌓기
  for i in range(num_layers):
    outputs = decoder_layer(dff=dff, d_model=d_model, num_heads=num_heads,
        dropout=dropout, name='decoder_layer_{}'.format(i),
    )(inputs=[outputs, enc_outputs, look_ahead_mask, padding_mask])

  return tf.keras.Model(
      inputs=[inputs, enc_outputs, look_ahead_mask, padding_mask],
      outputs=outputs,
      name=name)








############################### 트랜스포머
############################### 트랜스포머 조립
# 지금까지 구현한 인코더와 디코더 함수를 조합하여 트랜스포머를 조립
# 인코더의 출력은 디코더에서 인코더-디코더 어텐션에서 사용되기 위해 디코더로 전달
# 디코더의 끝단에는 다중 클래스 분류 문제를 풀 수 있도록, vocab_size 만큼의 뉴런을 가지는 출력층을 추가(다중클래스 분류 => 소프트맥스)

def transformer(vocab_size, num_layers, dff,
                d_model, num_heads, dropout,
                name="transformer"):
  # 인코더의 입력
  inputs = tf.keras.Input(shape=(None,), name="inputs")

  # 디코더의 입력
  dec_inputs = tf.keras.Input(shape=(None,), name="dec_inputs")

  # 인코더의 패딩 마스크
  enc_padding_mask = tf.keras.layers.Lambda(
      create_padding_mask, output_shape=(1, 1, None),
      name='enc_padding_mask')(inputs)

  # 디코더의 룩어헤드 마스크(첫번째 서브층)
  look_ahead_mask = tf.keras.layers.Lambda(
      create_look_ahead_mask, output_shape=(1, None, None),
      name='look_ahead_mask')(dec_inputs)

  # 디코더의 패딩 마스크(두번째 서브층)
  dec_padding_mask = tf.keras.layers.Lambda(
      create_padding_mask, output_shape=(1, 1, None),
      name='dec_padding_mask')(inputs)

  # 인코더의 출력은 enc_outputs. 디코더로 전달된다.
  enc_outputs = encoder(vocab_size=vocab_size, num_layers=num_layers, dff=dff,
      d_model=d_model, num_heads=num_heads, dropout=dropout,
  )(inputs=[inputs, enc_padding_mask]) # 인코더의 입력은 입력 문장과 패딩 마스크

  # 디코더의 출력은 dec_outputs. 출력층으로 전달된다.
  dec_outputs = decoder(vocab_size=vocab_size, num_layers=num_layers, dff=dff,
      d_model=d_model, num_heads=num_heads, dropout=dropout,
  )(inputs=[dec_inputs, enc_outputs, look_ahead_mask, dec_padding_mask])

  # 다음 단어 예측을 위한 출력층
  outputs = tf.keras.layers.Dense(units=vocab_size, name="outputs")(dec_outputs)

  return tf.keras.Model(inputs=[inputs, dec_inputs], outputs=outputs, name=name)






############################### 트랜스포머
############################### 트랜스포머 하이퍼파라미터 세팅부
# 트랜스포머의 하이퍼파라미터를 임의로 정하고 모델을 만들기
# 단어 집합의 크기로부터 룩업 테이블을 수행할 임베딩 테이블과 포지셔널 인코딩 행렬의 행의 크기를 결정할 수 있습니다.

# 단어 집합의 크기는 임의로 9,000으로 정했습니다.
small_transformer = transformer(
    vocab_size = 9000,
    num_layers = 4,
    dff = 512,
    d_model = 128,
    num_heads = 4,
    dropout = 0.3,
    name="small_transformer")


tf.keras.utils.plot_model(
    small_transformer, to_file='small_transformer.png', show_shapes=True)




############################### 트랜스포머
############################### 트랜스포머 손실함수 정의부
# 다중 클래스 분류 문제를 풀 예정이므로 크로스 엔트로피 함수를 손실 함수로 정의합니다.
def loss_function(y_true, y_pred):
  y_true = tf.reshape(y_true, shape=(-1, MAX_LENGTH - 1))

  loss = tf.keras.losses.SparseCategoricalCrossentropy(
      from_logits=True, reduction='none')(y_true, y_pred)

  mask = tf.cast(tf.not_equal(y_true, 0), tf.float32)
  loss = tf.multiply(loss, mask)

  return tf.reduce_mean(loss)


############################### 트랜스포머
############################### 트랜스포머 학습률
# 학습률 스케줄러(Learning rate Scheduler)는 미리 학습 일정을 정해두고 그 일정에 따라 학습률이 조정되는 방법입니다. 트랜스포머의 경우 사용자가 정한 단계까지는 학습률을 증가시켰다가 단계에 이르면 학습률을 점차적으로 떨어트리는 방식을 사용합니다.
class CustomSchedule(tf.keras.optimizers.schedules.LearningRateSchedule):

  def __init__(self, d_model, warmup_steps=4000):
    super(CustomSchedule, self).__init__()
    self.d_model = d_model
    self.d_model = tf.cast(self.d_model, tf.float32)
    self.warmup_steps = warmup_steps

  def __call__(self, step):
    arg1 = tf.math.rsqrt(step)
    arg2 = step * (self.warmup_steps**-1.5)

    return tf.math.rsqrt(self.d_model) * tf.math.minimum(arg1, arg2)


# 학습률의 변화를 시각화해봅시다.
sample_learning_rate = CustomSchedule(d_model=128)

plt.plot(sample_learning_rate(tf.range(200000, dtype=tf.float32)))
plt.ylabel("Learning Rate")
plt.xlabel("Train Step")













############################### 트랜스포머
############################### 트랜스포머 챗봇 실구현부★★★★★★★★★★★★★★★★★★★★






"""# 챗봇 구현부"""
# PYTHON
import pandas as pd
import urllib.request
import tensorflow_datasets as tfds
import tensorflow as tf
import time
import numpy as np
import matplotlib.pyplot as plt
import re


# ★★★★★★★★★★★★★★★★★★★★DB 생성&로드★★★★★★★★★★★★★★★★★★★★
# SQL
import pymysql
# SQL작업 끝나면 끝부분에서 curs.close()랑
# curs.commit() 사용하여 작업 내용 SQL서버로 저장

# DB NAME = transformer_chatbot
# TABLE NAME = chatbot_table
# COLUMS = [question, answer, category]

# MySQL Connection 연결
conn = pymysql.connect(host='localhost', user='root', password='dkdlxl', db='transformer_chatbot', charset='utf8')

# Connection 으로부터 Cursor 생성
curs = conn.cursor()

# select문으로 데이터 읽기
# sql = "SHOW TABLES;"  # use로 되어있는 테이블 확인
sql = "select * from chatbot_table;"

# execute메소드로 위 문장을 SQL 서버로 전송
curs.execute(sql)

# 데이타 Fetch
rows = curs.fetchall()

# read_sql사용하여 train_data에 pandas로 sql문 read해온다.
train_data = pd.read_sql(sql, con=conn)

# train_data
# columns = Q컬럼 A컬럼 label컬럼
# 예시 = 밥먹을까나, 안먹었을듯, 0  순으로 콤마로 구분해놓음
 
# Connection 닫기
curs.close()

# 외부 저장소에서 csv파일을 다운로드(sql에서 ansi로 read해서 utf8로 가공하니까 ansi로 저장)
# urllib.request.urlretrieve("https://raw.githubusercontent.com/songys/Chatbot_data/master/ChatbotData.csv", filename="./_data/ChatBotData_ANSI.csv")

# 데이터 전부를 sql로 import한다 (SQL상 기본 컬럼 밑 세팅은 이미 SQL-WORKBENCH 상에서 완료한 상태, 사실 이 작업도 워크벤치에서 하는게 편함)
# import_data = "LOAD DATA LOCAL INFILE 'd:/personal_project/_data/ChatBotData_ANSI.csv' INTO TABLE transformer_chatbot.chatbot_table FIELDS ENCLOSED BY '"' TERMINATED BY ',' ESCAPED BY '"' LINES TERMINATED BY '\n';"
# curs.execute(import_data)

# SQL 서버 망가져서 직접 csv파일 연동해야 될 경우 사용
# train_data = pd.read_csv('ChatBotData.csv')
# train_data = pd.read_csv('./_data/ChatBotData.csv')






# ★★★★★★★★★★★★★★★★★★★★트랜스포머 전처리부★★★★★★★★★★★★★★★★★★★★

# 데이터가 로드됐다면 상위 5개의 샘플을 출력해본다.
train_data.head()
# 주어진 열은 Q  A  label 이다.

print('챗봇 샘플의 개수 :', len(train_data))
# 챗봇 샘플의 개수 : 11823
# 총 샘플의 개수는 11,823개이다.

# 불필요한 Null 값이 있는지 확인해 본다
print(train_data.isnull().sum())
# null은 존재하지 않는다.


# 본 코드에서는 토큰화를 위해 형태소 분석기는 사용하지 않고
# 학습 기반의 토크나이저를 사용하기에 원 데이터의 ?나 ., ! 같은 구두점을 미리 처리해 둬야 한다.
# 이 구두점을 단순 제거도 가능하지만 여기선 구두점 앞 공백을 추가하여 다른 문자와 구분한다.

# question 작업 진행
questions = []
for sentence in train_data['Q']:
    # 구두점에 대해서 띄어쓰기
    # ex) 12시 땡! -> 12시 땡 !
    
    # 파이썬 re는 정규표현식 라이브러리이다.
    # ※참고※ https://engineer-mole.tistory.com/238
    # re.sub 함수 : 복잡한 패턴의 문자열을 치환 & 삭제
    # re.sub(치환하고 싶은 문자열(정규표현), 새로운 문자열（정규표현）, 대상변수 [,치환횟수])

              # # # re.sub사용 예제(본문과 무관함)
              # # import re
              # # text = "abc123def456ghi"
              # # new_text = re.sub(r"[a-z]", "", text)
              # # print(new_text)
              # # 123456
              # # 첫 번째 인수(치환하고 싶은 문자열)에 입력되어 있는 「r”[a-z]”」는 소문자의 알파벳 모두를 의미하는 정규표현이다. 「r」은 raw string으로 정규표현시에 입력을 추천하고 있다. 
              # # 두 번째 인수에는 「””」를 입력하고 있다. 쌍따옴표 안에 어떠한 문

    # 여기선 "? . ! , "등을  "(공백)(숫자만큼일치하는 대상 문자)(공백)"
    sentence = re.sub(r"([?.!,])", r" \1 ", sentence)
    
    # strip()은 문자열의 맨 앞과 맨 끝에 있는 필요없는 문자를 삭제하는 메소드이다.
    # 문자열에는 앞 뒤로 불필요한 빈 공백 스페이스가 있다. strip 메소드의 인수를 공백으로하면 이 스페이스를 삭제해준다
    sentence = sentence.strip() # strip([chars]) : 인자로 전달된 문자를 String의 왼쪽과 오른쪽에서 제거한다.
                                # 문자열.strip()은 모든 공백을 제거할 수 있는 replace 함수와 달리 양쪽 끝에 있는 공백을 제거할 수 있다.
    questions.append(sentence)  # sentence를 array 맨 끝에 추가

# answer에 대해서도 똑같이 작업
answers = []
for sentence in train_data['A']:
    # 구두점에 대해서 띄어쓰기
    # ex) 12시 땡! -> 12시 땡 !
    sentence = re.sub(r"([?.!,])", r" \1 ", sentence)
    sentence = sentence.strip()
    answers.append(sentence)

len(questions)

print(questions[:5])
# ['12시 땡 !', '1지망 학교 떨어졌어', '3박4일 놀러가고 싶다', '3박4일 정도 놀러가고 싶다', 'PPL 심하네']
print(answers[:5])
# ['하루가 또 가네요 .', '위로해 드립니다 .', '여행은 언제나 좋죠 .', '여행은 언제나 좋죠 .', '눈살이 찌푸려지죠 .']
# '하루가 또 가네요 .'와 같이 구두점 앞에 띄어쓰기가 추가되어 분리된 것을 확인할 수 있다.

# 자주 사용되는 서브워드 단위로 토큰을 분리하는 토크나이저로 학습 데이터로부터 학습하여 서브워드로 구성된 단어 집합을 생성 (참고: 서브워드 토크나이저)
# 서브워드텍스트인코더를 사용하여 질문과 답변을 모두 포함한 단어 집합(Vocabulary) 생성
# deprecated : tfds includes a set of TextEncoders as well as a Tokenizer to enable expressive, performant, and reproducible natural language research.
# 서브워드텍스트인코더 : Tensorflow 2.3+ 버전에서는 tfds.features.text 대신 tfds.deprecated.text라고 작성해야 합니다.
# 텐서플로우 설명 : https://www.tensorflow.org/datasets/api_docs/python/tfds/deprecated/text?hl=ko
tokenizer = tfds.deprecated.text.SubwordTextEncoder.build_from_corpus(
    questions + answers, target_vocab_size=2**13)

# 인코더-디코더 모델 계열에는 디코더의 입력으로 사용할 시작을 의미하는 시작 토큰 SOS와 종료 토큰 EOS 또한 존재합니다.
# 해당 토큰들도 단어 집합에 포함시킬 필요가 있으므로 이 두 토큰에 정수를 부여한다.
# 시작 토큰과 종료 토큰에 대한 정수 부여 (vacab_size = 단어집합의 크기)
START_TOKEN, END_TOKEN = [tokenizer.vocab_size], [tokenizer.vocab_size + 1]

# 시작 토큰과 종료 토큰을 고려하여 단어 집합의 크기를 + 2 해줌
VOCAB_SIZE = tokenizer.vocab_size + 2
########################################################################################################
# print('시작 토큰 번호 :',START_TOKEN)
# # 시작 토큰 번호 : [8178]
# print('종료 토큰 번호 :',END_TOKEN)
# # 종료 토큰 번호 : [8179]
# print('단어 집합의 크기 :',VOCAB_SIZE)
# # 단어 집합의 크기 : 8180
# # 패딩에 사용될 0번 토큰부터 마지막 토큰인 8,179번 토큰까지의 개수를 카운트하면 단어 집합의 크기는 8,180개 이다.

# # 서브워드텍스트인코더 토크나이저의 .encode()를 사용하여 텍스트 시퀀스를 정수 시퀀스로 변환.

# # 임의로 선택한 20번 질문 샘플. 즉, questions[20]을 가지고 정수 인코딩을 진행해본다.
# print('Tokenized sample question: {}'.format(tokenizer.encode(questions[20])))
# # 임의의 질문 샘플을 정수 인코딩 : [5766, 611, 3509, 141, 685, 3747, 849]

# # 서브워드텍스트인코더 토크나이저의 .encode()와 decode() 테스트해보기

# # 임의의 입력 문장을 sample_string에 저장
# sample_string = questions[20]

# # encode() : 텍스트 시퀀스 --> 정수 시퀀스
# tokenized_string = tokenizer.encode(sample_string)
# print ('정수 인코딩 후의 문장 {}'.format(tokenized_string))

# # decode() : 정수 시퀀스 --> 텍스트 시퀀스
# original_string = tokenizer.decode(tokenized_string)
# print ('기존 문장: {}'.format(original_string))
# # 정수 인코딩 후의 문장 [5766, 611, 3509, 141, 685, 3747, 849]
# # 기존 문장: 가스비 비싼데 감기 걸리겠어


# # 각 정수는 각 단어와 어떻게 mapping되는지 병렬로 출력
# # 서브워드텍스트인코더는 의미있는 단위의 서브워드로 토크나이징한다. 띄어쓰기 단위 X 형태소 분석 단위 X
# for ts in tokenized_string:
#   print ('{} ----> {}'.format(ts, tokenizer.decode([ts])))
########################################################################################################

# # 샘플 1개를 가지고 정수 인코딩과 디코딩을 수행해보았습니다. 이번에는 전체 데이터에 대해서 정수 인코딩과 패딩을 진행합니다. 이를 위한 함수로 tokenize_and_filter()를 만듭니다. 여기서는 임의로 패딩의 길이는 40으로 정했다.
# 최대 길이를 40으로 정의
MAX_LENGTH = 40

# 토큰화 / 정수 인코딩 / 시작 토큰과 종료 토큰 추가 / 패딩
def tokenize_and_filter(inputs, outputs):
  tokenized_inputs, tokenized_outputs = [], []
  
  for (sentence1, sentence2) in zip(inputs, outputs):
    # encode(토큰화 + 정수 인코딩), 시작 토큰과 종료 토큰 추가
    sentence1 = START_TOKEN + tokenizer.encode(sentence1) + END_TOKEN
    sentence2 = START_TOKEN + tokenizer.encode(sentence2) + END_TOKEN

    tokenized_inputs.append(sentence1)
    tokenized_outputs.append(sentence2)
  
  # 패딩
  tokenized_inputs = tf.keras.preprocessing.sequence.pad_sequences(
      tokenized_inputs, maxlen=MAX_LENGTH, padding='post')
  tokenized_outputs = tf.keras.preprocessing.sequence.pad_sequences(
      tokenized_outputs, maxlen=MAX_LENGTH, padding='post')
  
  return tokenized_inputs, tokenized_outputs

questions, answers = tokenize_and_filter(questions, answers)

# 정수 인코딩과 패딩이 진행된 후의 데이터의 크기를 확인한다.
print('질문 데이터의 크기(shape) :', questions.shape)
# 질문 데이터의 크기(shape) : (11823, 40)
print('답변 데이터의 크기(shape) :', answers.shape)
# 답변 데이터의 크기(shape) : (11823, 40)

# 0번째 샘플을 임의로 출력(길이 40을 맞추기 위해 뒤에 0이 패딩된 것을 확인할 수 있다.)
print(questions[0])
# [8178 7915 4207 3060   41 8179    0    0    0    0    0    0    0    0
#     0    0    0    0    0    0    0    0    0    0    0    0    0    0
#     0    0    0    0    0    0    0    0    0    0    0    0]
print(answers[0])
# [8178 3844   74 7894    1 8179    0    0    0    0    0    0    0    0
#     0    0    0    0    0    0    0    0    0    0    0    0    0    0
#     0    0    0    0    0    0    0    0    0    0    0    0]

print('단어 집합의 크기(Vocab size): {}'.format(VOCAB_SIZE))
print('전체 샘플의 수(Number of samples): {}'.format(len(questions)))

# 텐서플로우 dataset을 이용하여 셔플(shuffle)을 수행하되, 배치 크기로 데이터를 묶는다.
# 또한 이 과정에서 교사 강요(teacher forcing)을 사용하기 위해서 디코더의 입력과 실제값 시퀀스를 구성한다.
# 교사강요 - 디코더는 추론한 단어를 다시 입력으로 넣어 한번더 추론하는 교사 강요(Teacher Forcing)를 통해 학습함
BATCH_SIZE = 64
BUFFER_SIZE = 20000

# tf.data.Dataset을 사용하여 데이터를 배치 단위로 불러올 수 있다.
# 디코더의 실제값 시퀀스에서는 시작 토큰을 제거해야 한다.
dataset = tf.data.Dataset.from_tensor_slices((
    {
        'inputs': questions,
        'dec_inputs': answers[:, :-1] # 디코더의 입력. 마지막 패딩 토큰이 제거된다.
    },
    {
        'outputs': answers[:, 1:]  # 맨 처음 토큰이 제거된다. 다시 말해 시작 토큰이 제거된다.
    },
))

dataset = dataset.cache()
dataset = dataset.shuffle(BUFFER_SIZE)
dataset = dataset.batch(BATCH_SIZE)
dataset = dataset.prefetch(tf.data.experimental.AUTOTUNE)

# 임의의 샘플에 대해서 [:, :-1]과 [:, 1:]이 어떤 의미를 가지는지 테스트해본다.
print(answers[0]) # 기존 샘플
# [8178 3844   74 7894    1 8179    0    0    0    0    0    0    0    0
#     0    0    0    0    0    0    0    0    0    0    0    0    0    0
#     0    0    0    0    0    0    0    0    0    0    0    0]
print(answers[:1][:, :-1]) # 마지막 패딩 토큰 제거하면서 길이가 39가 된다.
# [[8178 3844   74 7894    1 8179    0    0    0    0    0    0    0    0
#      0    0    0    0    0    0    0    0    0    0    0    0    0    0
#      0    0    0    0    0    0    0    0    0    0    0]]
print(answers[:1][:, 1:]) # 맨 처음 토큰이 제거된다. 다시 말해 시작 토큰이 제거된다. 길이는 역시 39가 된다.
# [[3844   74 7894    1 8179    0    0    0    0    0    0    0    0    0
#      0    0    0    0    0    0    0    0    0    0    0    0    0    0
#      0    0    0    0    0    0    0    0    0    0    0]]






# ★★★★★★★★★★★★★★★★★★★★트랜스포머 생성부★★★★★★★★★★★★★★★★★★★★


# 하이퍼 파라미터를 조정하여 실제 Attention is all you need 논문 보다는 작은 모델을 만든다.
# ※ 여기서 참고 ※
# '파라미터'와 '하이퍼 파라미터'는 명확히 다른 개념이다!
# 파라미터는 모델 내부에서 결정되는 변수입니다. 또한 그 값은 데이터로부터 결정된다.(모델 내부적으로 결정되는 값이기에 사용자에 의해 조정되지 않는다)
# 하이퍼 파라미터는 모델링할 때 사용자가 직접 세팅해주는 값이다.
# 본 코드에서 설정한 하이퍼 파라미터 값은,

# dimension of model = 256
#  └ 트랜스포머의 인코더와 디코더에서의 정해진 입력과 출력의 크기를 의미합니다. 임베딩 벡터의 차원 또한 d_model이며, 각 인코더와 디코더가 다음 층의 인코더와 디코더로 값을 보낼 때에도 이 차원을 유지함
# number of layers = 2
#  └ 트랜스포머에서 하나의 인코더와 디코더를 층으로 생각하였을 때, 트랜스포머 모델에서 인코더와 디코더가 총 몇 층으로 구성되었는지를 의미함
# number of heads = 8
#  └ 트랜스포머에서는 어텐션을 사용할 때, 한 번 하는 것 보다 여러 개로 분할해서 병렬로 어텐션을 수행하고 결과값을 다시 하나로 합치는 방식을 택하였다. 이때 이 병렬의 개수를 의미함.
# dimension of feed forward layers = 512
#  └ 트랜스포머 내부에는 피드 포워드 신경망이 존재하며 해당 신경망의 은닉층의 크기를 의미한다. 피드 포워드 신경망의 입력층과 출력층의 크기는 d_model이다.

# Attention(Q, K, V) = softmax(QK^T / root(d_k) )
# 각 head의 Q, K, V마다 다른 W를 곱해줌으로써 각각 linear transformation형태를 취해준다
# 즉, head마다 필요한 다른 정보(feature)를 attention을 통해 encoding할 수 있게 된다.
# 논문에선 hidden size를 512로 하고 이를 8개의 head로 나누어 각 head의 hidden size는 64가 되도록 하였다.


# 이 모델에서 drop out은 거의 필수적인 수준으로 꼭 필요하다.


# Keras에서 생성 한 모든 상태를 재설정합니다.(호출하여 전역 상태가 해제됨. 이는 특히 메모리가 제한된 경우 이전 모델 및 레이어의 혼란을 방지하는 데 도움)
# With `clear_session()` called at the beginning,
# Keras starts with a blank state at each iteration
# and memory consumption is constant over time.
tf.keras.backend.clear_session()

# Hyper-parameters setting
NUM_LAYERS = 2
D_MODEL = 256
NUM_HEADS = 8
DFF = 512
DROPOUT = 0.1

model = transformer(
    vocab_size=VOCAB_SIZE,
    num_layers=NUM_LAYERS,
    dff=DFF,
    d_model=D_MODEL,
    num_heads=NUM_HEADS,
    dropout=DROPOUT)

MAX_LENGTH = 40

# 학습률과 옵티마이저를 정의
# 옵티마이저는 adam을 사용
learning_rate = CustomSchedule(D_MODEL)

optimizer = tf.keras.optimizers.Adam(
    learning_rate, beta_1=0.9, beta_2=0.98, epsilon=1e-9)

def accuracy(y_true, y_pred):
  # ensure labels have shape (batch_size, MAX_LENGTH - 1)
  y_true = tf.reshape(y_true, shape=(-1, MAX_LENGTH - 1))
  return tf.keras.metrics.sparse_categorical_accuracy(y_true, y_pred)

# 모델 컴파일
model.compile(optimizer=optimizer, loss=loss_function, metrics=[accuracy])

# 총 50회 모델을 학습하겠다.
EPOCHS = 50

model.fit(dataset, epochs=EPOCHS)








# ★★★★★★★★★★★★★★★★★★★★트랜스포머 평가부★★★★★★★★★★★★★★★★★★★★

# changed  # changed  # changed  # changed  # changed  # changed  
def preprocess_sentence(sentence):
  sentence = re.sub(r"([?.!,])", r" \1 ", sentence) # 구두점 주변 여백 생성
  sentence = sentence.strip()                       # 문장 양끝단 공백 제거
  return sentence



def evaluate(sentence):
  # 입력 문장에 대한 전처리
  sentence = preprocess_sentence(sentence)

  # 입력 문장에 시작 토큰과 종료 토큰을 추가(<START> <END>)
  sentence = tf.expand_dims(
      START_TOKEN + tokenizer.encode(sentence) + END_TOKEN, axis=0)

  output = tf.expand_dims(START_TOKEN, 0)

  # 디코더의 예측 시작
  for i in range(MAX_LENGTH):
    predictions = model(inputs=[sentence, output], training=False)

    # 현재(마지막) 시점의 예측 단어를 받아온다.
    predictions = predictions[:, -1:, :]
    # argmax로 가장 높은 신뢰도를 가진 레이블을 찾는다.
    # tf.cast는 텐서를 새로운 자료형으로 변환한다.
    # tf.cast(x, dtype, name=None)
    # x 또는 x.values 를 dtype형으로 변환.
    predicted_id = tf.cast(tf.argmax(predictions, axis=-1), tf.int32)

    # 만약 마지막 시점의 예측 단어가 종료 토큰이라면 예측을 중단한다.
    if tf.equal(predicted_id, END_TOKEN[0]):
      break

    # 마지막 시점의 예측 단어를 출력에 연결한다.
    # 이는 for문을 통해서 디코더의 입력으로 사용될 예정이다.
    output = tf.concat([output, predicted_id], axis=-1)

  # 단어 예측이 모두 끝났다면 output을 리턴한다.
  # squeeze 함수는 차원을 줄여주는 함수이지만 크기가 1인 차원만 제거하는 함수이다.
  # axis 를 통해서 특정 위치에 있는 크기가 1인 차원만 제거할 수도있다.
                # # squeeze 사용 예제
                # -> axis 를 지정할 경우 ( [2,4] )
                # tf.shape(tf.squeeze(example , [2,4]))
                # ->결과 : array([1, 2, 3, 1]

  return tf.squeeze(output, axis=0)


def predict(sentence):
  prediction = evaluate(sentence)

  # prediction == 디코더가 리턴한 챗봇의 대답에 해당하는 정수 시퀀스
  # tokenizer.decode()를 통해 정수 시퀀스를 문자열로 디코딩한다.
  predicted_sentence = tokenizer.decode(
      [i for i in prediction if i < tokenizer.vocab_size])

  print('Input: {}'.format(sentence))
  print('Output: {}'.format(predicted_sentence))

  return predicted_sentence

# output = predict('밥 뭐먹을까?')

# output = predict("술 먹을까 말까")

# output = predict("너무 화가나")

# output = predict("게임하고싶은데 할래?")

# output = predict("나 너 좋아하는 것 같아")

# output = predict("딥 러닝 자연어 처리를 잘 하고 싶어")

output = predict('Hey stupid!')

output = predict('operation cwal 치트키ㅎ')

